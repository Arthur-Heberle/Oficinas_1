O código do projeto, produzido na linguagem de programação PYTHON em sua versão 3.12.10, consiste em dois arquivos: app.y e pi_reciever.py. No computador do usuário ficará o app.py, onde nele é criado um servidor utilizando o framework Flask, no qual o servidor web, utilizando um front-end feito em html, processa o upload de um arquivo (.txt, .docx ou .pdf), extrai seu texto, insere as palavras deste texto em um array e por fim, envia o texto e o array de palavras para a Raspberry Pi. O sistema portanto possui em seu site, um lugar para inserir o arquivo de texto, um botão para enviar o arquivo, a opção de escolher o tempo entre cada letra produzida pelos motores, e um botão para então iniciar a leitura na Raspberry.

Em pi_receiver.py, arquivo no qual roda diretamente no Raspberry Pi 4, o código consiste, majoritariamente, em duas principais funções ou rotas do próprio servidor (também utilizando a biblioteca Flask). A primeira função recebe o texto e o array de palavras enviado pelo servidor Flask do app.py, salva-os na memória, e então, para fins de agilidade na hora da reprodução, utilizando a biblioteca gTTs da google, cria arquivos de áudio respectivos a cada palavra do array. Já a segunda função, agora mais complexa, é incializada após o usuário clicar no botão do servidor do app.py para iniciar a leitura, 

 Sua principal função é receber, via rede, o texto enviado pelo servidor Flask do app.py, armazenar esse conteúdo em memória e processá-lo letra por letra para gerar a saída em Braille e em áudio. Cada caractere recebido é traduzido para sua representação em Braille usando motores servo conectados a pinos GPIO específicos, com configurações definidas para cada ponto da célula Braille. Além disso, palavras e letras são convertidas em arquivos de áudio com o uso da biblioteca gTTS e reproduzidas por meio do pygame, permitindo que o usuário também ouça o conteúdo textual.

O sistema inclui funcionalidades de acessibilidade e controle interativo através de botões físicos conectados ao Raspberry Pi. Esses botões permitem pausar a execução, repetir palavras, e ajustar a velocidade da leitura. Há também um potenciômetro I2C usado para controlar o volume de áudio dinamicamente. O código trata eventos de botão com interrupções e também com monitoramento contínuo em uma thread separada, garantindo uma experiência fluida e responsiva ao usuário durante a execução do texto.

Além disso, o código organiza suas funcionalidades em seções claras: configuração de pinos e PWM para servomotores, leitura de áudio, limpeza de caracteres especiais, manipulação de botões, e rotas de servidor Flask para receber e executar o texto. Ele mantém boas práticas como o uso de multithreading para não bloquear o servidor, manipulação robusta de exceções, e uso eficiente de bibliotecas externas como unidecode, smbus2 e pygame. Ao final da execução ou em caso de erro, o código realiza a limpeza dos recursos, como reset dos servos e encerramento de arquivos de áudio e GPIO.